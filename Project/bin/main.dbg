***********************************************************************
*
* Title:          Simple Memory Access Program
* 
* Objective:      CMPEN 472 Homework 6
*
* Revision:       V1.7
*
* Date:           Feb. 28, 2025
*
* Programmer:     Kuria Mbatia
*
* Company:        The Pennsylvania State University
*
* Algorithm:      Simple SCI Serial I/O and Memory Access
*
* Register use:   A: Command processing, temp calculations
*                 B: Bit manipulation, counters
*                 X,Y: Pointers and memory access
*                 Z: Not used
*
* Memory use:     $3000-$30FF: Variables and data
*                 $3100-$xxxx: Program
*
* Input:          Terminal input via SCI port
*
* Output:         Terminal output via SCI port
*
* Observation:    This is a command-line memory access program that allows
*                 users to view and modify memory contents.
*
* Commands:       S$xxxx - Show the contents of memory location in word
*                 W$xxxx yyyy - Write data word to memory location
*                 QUIT - Quit program, run 'Type writer' program
*
***********************************************************************
* Parameter Declaration Section
*
* Export Symbols
            XDEF        pstart      ; Program entry point
            ABSENTRY    pstart      ; For absolute assembly

* Symbols and Macros
PORTB       EQU         $0001       ; Port B data register
DDRB        EQU         $0003       ; Port B data direction register

SCIBDH      EQU         $00C8       ; SCI Baud Register High
SCIBDL      EQU         $00C9       ; SCI Baud Register Low
SCICR2      EQU         $00CB       ; SCI Control Register 2
SCISR1      EQU         $00CC       ; SCI Status Register 1
SCIDRL      EQU         $00CF       ; SCI Data Register Low

CR          EQU         $0D         ; ASCII carriage return
LF          EQU         $0A         ; ASCII line feed
SPACE       EQU         $20         ; ASCII space
NULL        EQU         $00         ; ASCII null
DOLLAR      EQU         $24         ; ASCII $ character

; Define safe memory range for the program
SAFE_MEM_START EQU     $0000       ; Start of safe memory area (allow any address)
SAFE_MEM_END   EQU     $FFFF       ; End of safe memory area (allow any address)

MAX_CMD_LEN EQU         80          ; Maximum command length

***********************************************************************
* Data Section - Variables and Strings
***********************************************************************
            ORG         $3800       ; Start of data section

cmdBuffer   DS.B        MAX_CMD_LEN ; Command input buffer
cmdLength   DS.B        1           ; Length of command
address     DS.W        1           ; Memory address for commands
dataValue   DS.W        1           ; Data value for W command
;tempByte    DS.B        1           ; Temporary storage
tempPtr     DS.W        1
isHexData   DS.B        1           ; Flag for hex/decimal data format
decBuffer   DS.B        6           ; Buffer for decimal conversion
hexValid    DS.B        1           ; Flag to track if all chars are valid hex
digCount    DS.B        1           ; Digit counter for parsing
tempWord    DS.W        1           ; Temporary word storage
debugFlag   DS.B        1           ; Flag for debugging

***********************************************************************
* Program Section
***********************************************************************
            ORG         $3100       ; Start of program section

; Program constants (all message strings in program section to save data space)
msgPrompt   DC.B        '>', NULL
msgLF       DC.B        CR, LF, NULL
welcome1    DC.B        'Welcome to the Simple Memory Access Program!', CR, LF, NULL
welcome2    DC.B        'Enter one of the following commands (examples shown below)', CR, LF, NULL
welcome3    DC.B        'and hit ', $27, 'Enter', $27, '.', CR, LF, CR, LF, NULL
example1    DC.B        '>S$3000                  ;to see the memory content at $3000 and $3001', CR, LF, NULL
example2    DC.B        '>W$3003 $126A            ;to write $126A to memory locations $3003 and $3004', CR, LF, NULL
example3    DC.B        '>W$3003 4714             ;to write $126A to memory location $3003 and $3004', CR, LF, NULL
example4    DC.B        '>QUIT                    ;quit the Simple Memory Access Program', CR, LF, NULL
msgInvCmd   DC.B        'Invalid command. Use one of the following:', CR, LF
            DC.B        ' S$xxxx   - Show memory contents at address xxxx', CR, LF
            DC.B        ' W$xxxx v - Write value v to address xxxx (v can be decimal or $hex)', CR, LF
            DC.B        ' QUIT     - Exit to typewriter mode', CR, LF, NULL
msgInvAddr  DC.B        'invalid input, address', CR, LF, NULL
msgInvData  DC.B        'invalid input, data', CR, LF, NULL
msgQuit     DC.B        'Type-writing now, hit any keys:', CR, LF, NULL
spaceArrow  DC.B        ' => ', NULL

; Add a debug print macro to help diagnose issues
msgDebug    DC.B        'Debug: Value=', NULL

printDebug  
            ; Print debug message header
            PSHD                    ; Save D register
            
            LDX         #msgDebug
            JSR         printmsg
            
            ; Print value in D register
            PULD                    ; Restore D
            PSHD                    ; Save again
            JSR         printWordHex
            
            ; Print newline
            LDX         #msgLF
            JSR         printmsg
            
            PULD                    ; Restore D
            RTS

pstart      LDS         #$3F00      ; Initialize stack pointer to valid RAM area

            ; Initialize hardware
            LDAA        #%11111111  ; Set PORTB as output
            STAA        DDRB
            CLR         PORTB       ; Clear all outputs

            ; Initialize serial port - FIXED VALUES FOR 9600 BAUD AT 24MHZ
            CLR         SCIBDH      ; Set baud rate high byte to 0
            LDAA        #$9C        ; Low byte value for 9600 baud at 24MHz (156)
            STAA        SCIBDL      ; 24MHz/(16*156) = 9615 baud (close to 9600)
            LDAA        #$0C        ; Enable SCI transmitter and receiver
            STAA        SCICR2

            ; Clear all variables to make sure we start clean
            LDX         #cmdBuffer
            LDY         #debugFlag  ; End of variables
            
clearVars   CLR         0,X         ; Clear this variable
            INX                     ; Next variable
            CPX         Y           ; Reached the end?
            BLS         clearVars   ; If not, continue clearing
            
            ; Show welcome message and instructions
            LDX         #welcome1
            JSR         printmsg
            LDX         #welcome2
            JSR         printmsg
            LDX         #welcome3
            JSR         printmsg
            
            ; Show example commands
            LDX         #example1
            JSR         printmsg
            LDX         #example2
            JSR         printmsg
            LDX         #example3
            JSR         printmsg
            LDX         #example4
            JSR         printmsg

mainLoop    ; Reset the command length for next command
            CLR         cmdLength
            
            ; Show prompt
            LDX         #msgPrompt  ; Show prompt
            JSR         printmsg
            
            ; Get a new command
            JSR         getCommand  ; Get command from user
            TST         cmdLength   ; Check if command received
            BEQ         mainLoop    ; If empty command, restart
            
            ; Process the command
            JSR         processCmd  ; Process the command
            
            ; Always return to the main loop
            BRA         mainLoop    ; Return to main loop

***********************************************************************
* getCommand: Get command from user via serial input
*             Stores command in cmdBuffer and length in cmdLength
* Input:      None
* Output:     cmdBuffer, cmdLength
* Registers:  A, B, X, Y all modified
***********************************************************************
getCommand  
            ; Reset command length
            CLR         cmdLength   ; Reset command length
            
            ; Clear the entire command buffer first for safety
            LDX         #cmdBuffer  ; Point to command buffer
            LDY         #MAX_CMD_LEN ; Get buffer size
            
gcClearLoop CLR         0,X         ; Clear this byte
            INX                     ; Next byte
            DEY                     ; Decrement counter
            BNE         gcClearLoop ; If not done, continue
            
            ; Now get the command
            LDY         #cmdBuffer  ; Reset to start of buffer
            
gcLoop      JSR         getchar     ; Get a character
            CMPA        #CR         ; Check for Enter key
            BEQ         gcDone      ; If so, done
            
            ; Check maximum command length
            LDAB        cmdLength
            CMPB        #MAX_CMD_LEN-1  ; Ensure space for null
            BHS         gcLoop      ; Ignore if too long
            
            JSR         putchar     ; Echo character
            STAA        0,Y         ; Store in buffer
            INY                     ; Next buffer position
            INC         cmdLength   ; Count the character
            BRA         gcLoop      ; Get next character
            
gcDone      CLR         0,Y         ; Null-terminate buffer
            
            ; Print newline
            LDX         #msgLF
            JSR         printmsg
            
            RTS

***********************************************************************
* processCmd: Process the command in cmdBuffer
* Input:      cmdBuffer, cmdLength
* Output:     None
* Registers:  All modified
***********************************************************************
processCmd  
            LDX         #cmdBuffer  ; Point to command
            
            ; Check command length first
            LDAA        cmdLength
            CMPA        #1          ; At least 1 character needed
            BLO         invalidCmd
            
            ; Check first character - should be S, W, or Q (case insensitive)
            LDAA        0,X         ; Get first character
            
            ; Convert to uppercase for case-insensitive comparison
            CMPA        #'a'        ; Check if lowercase
            BLO         pcNotLower
            CMPA        #'z'
            BHI         pcNotLower
            SUBA        #$20        ; Convert to uppercase (a-z to A-Z)
            STAA        0,X         ; Store back to command buffer
            
pcNotLower  ; Now it's uppercase if it was lowercase
            CMPA        #'S'        ; Is it S command?
            BEQ         procShowCmd
            
            CMPA        #'W'        ; Is it W command?
            LBEQ         procWriteCmd
            
            CMPA        #'Q'        ; Is it Q?
            BNE         invalidCmd  ; If not S, W, or Q, invalid command
            
            ; Check if command is "QUIT"
            LDAB        cmdLength
            CMPB        #4          ; Must be exactly 4 chars for QUIT
            BNE         invalidCmd
            
            LDAA        1,X         ; Second character
            CMPA        #'U'
            BNE         invalidCmd
            LDAA        2,X         ; Third character
            CMPA        #'I'
            BNE         invalidCmd
            LDAA        3,X         ; Fourth character
            CMPA        #'T'
            BNE         invalidCmd
            
doQuit      ; QUIT command - go to typewriter mode
            LDX         #msgQuit
            JSR         printmsg
            JSR         typewriter
            ; No return - typewriter loops forever
            
invalidCmd  LDX         #msgInvCmd   ; Invalid command message
            JSR         printmsg
            RTS                      ; Return to main loop

procShowCmd ; Process S command - format should be S$xxxx
            ; Check for minimum command length - need at least "S$X"
            LDAA        cmdLength
            CMPA        #3
            BLO         invalidCmd
            
            LDAA    1,X             ; must be '$'
            CMPA    #DOLLAR
            BNE     invalidCmd

            LEAX    2,X             ; X -> first hex digit
            STX     tempPtr        ; tempPtr = pointer for parser
            JSR     parseHexValue   ; returns value in D, C=1 if OK
            BCC     invalidAddr     ; C=0 → bad hex or >4 digits

            STD     address         ; save parsed 16-bit address
            
            ; Execute show memory command
            JSR         showMemory
            
            RTS
            
invalidAddr LDX         #msgInvAddr  ; Invalid address message
            JSR         printmsg
            RTS

procWriteCmd ; Process W command - format should be W$xxxx data
        ; Check for minimum command length - need at least "W$X v" (5 chars)
        LDAA    cmdLength
        CMPA    #5
        BLO     invalidCmd

        LDAA    1,X             ; Check second char must be '$'
        CMPA    #DOLLAR
        BNE     invalidCmd

        ; Parse the address part
        LEAX    2,X             ; X -> first potential hex digit of address
        STX     tempPtr         ; Save pointer for parseHexValue
        JSR     parseHexValue   ; D = address, C=1 if OK, tempPtr updated
        BCC     invalidAddr     ; Branch if parseHexValue failed (C=0)

        STD     address         ; Save the successfully parsed 16-bit address

        ; Clear data value variable before parsing new data
        LDD     #0
        STD     dataValue

        ; Find the space separating address and data
        ; parseHexValue updated tempPtr to point AFTER the address
        LDY     tempPtr         ; Y points to the char after the parsed address

findSpace
        LDAA    0,Y             ; Get character
        CMPA    #NULL           ; End of string?
        BEQ     invalidData     ; No data found after address
        CMPA    #SPACE          ; Is it a space?
        BEQ     foundSpace      ; Yes, found the separator

        ; If the character after the address isn't a space or NULL,
        ; it implies invalid command format (e.g., S$3000ABC)
        ; According to examples, data must follow a space.
        BRA     invalidData     ; Treat as invalid data format

foundSpace  ; Found space, now skip any *additional* spaces
skipSpaces
        INY                     ; Point past the space
        LDAA    0,Y             ; Get the next character
        CMPA    #SPACE          ; Is it another space?
        BEQ     skipSpaces      ; Yes, skip it and check again
        CMPA    #NULL           ; Is it the end of the string?
        BEQ     invalidData     ; No data value found after space(s)

        ; Y now points to the first character of the data value
        ; A contains the first character of the data value
        STY     tempPtr         ; Store this pointer for data parsing routines

        ; Check if data starts with '$' (hex)
        CMPA    #DOLLAR
        BEQ     parseW_HexData  ; Branch if it's hex data

        ; --- Parse data as Decimal ---
        ; tempPtr is already pointing to the first decimal digit
        JSR     parseDecValue   ; D = parsed value, C=1 if OK
        BCC     invalidData     ; Branch if decimal parse failed

        STD     dataValue       ; Store parsed decimal data
        JSR     writeMemory     ; Write to memory and display
        RTS                     ; Return to main loop

parseW_HexData
        ; Y was pointing to '$', A contained '$'
        INY                     ; Skip the '$'
        LDAA    0,Y             ; Check if anything follows '$'
        CMPA    #NULL
        BEQ     invalidData     ; Error if just '$' with no digits
        CMPA    #SPACE          ; Error if space right after '$'
        BEQ     invalidData
        ; Y now points to the first hex digit of the data
        STY     tempPtr         ; Update tempPtr for parseHexValue

        JSR     parseHexValue   ; D = parsed value, C=1 if OK
        BCC     invalidData     ; Branch if hex parse failed

        STD     dataValue       ; Store parsed hex data
        JSR     writeMemory     ; Write to memory and display
        RTS                     ; Return to main loop

invalidData
        LDX     #msgInvData     ; Invalid data message
        JSR     printmsg
        RTS

***********************************************************************
* parseHexValue  –  convert up to four hex digits to a 16-bit value
*   entry :  tempByte  → pointer to first digit (‘0’–‘9’, ‘A’–‘F’, ‘a’–‘f’)
*   exit  :  D         = value (0-FFFFh)
*            tempByte  → first char that is not a hex digit
*            C-flag    = 1 success, 0 syntax error / > 4 digits
*   regs  :  A,B,X,Y clobbered
***********************************************************************

parseHexValue
            CLRA            ; D = 0
            CLRB
            STD   tempWord  ; tempWord will hold the running value
            LDY   tempPtr  ; Y traverses the string
            CLR   digCount

phv_loop    LDAA   0,Y            ; get next character
            JSR    isHexDigit
            BCC    phv_done       ; stop on first non-hex char

;------------ convert ASCII digit → 0-15 -------------------------------
            LDAA   0,Y
            JSR    hexCharToVal   ; A = nibble value (0-15)

;------------ value = (value << 4) + nibble ----------------------------
            PSHA                   ; save nibble on stack
            CLC                    ; *** clear carry BEFORE shifting ***

            LDD    tempWord        ; current 16-bit value
            LSLD                   ; ×2
            LSLD                   ; ×4
            LSLD                   ; ×8
            LSLD                   ; ×16
            STD    tempWord        ; store shifted value

            PULA                   ; A = nibble
            TAB                    ; B = nibble, A = 0
            CLRA
            ADDD   tempWord        ; add nibble
            STD    tempWord        ; save new result

            INY                    ; advance source pointer
            INC    digCount        ; count this digit
            LDAA   digCount
            CMPA   #4
            BLS    phv_loop        ; loop while ≤ 4 digits

            BRA    phv_error       ; >4 digits → error



phv_done    TST   digCount
            BEQ   phv_error         ; no digits at all
            STY   tempPtr          ; update caller's pointer
            LDD   tempWord
            SEC                     ; good exit
            RTS

phv_error   CLRA
            CLRB
            CLC
            RTS


***********************************************************************
* parseDecValue: Parse an unsigned decimal number from string
* Input:      tempPtr -> pointer to first potential decimal digit ('0'-'9')
* Output:     D         = Parsed decimal value (0-65535)
* tempPtr -> points to first char *after* parsed digits
* Carry flag = set if valid number parsed, clear if invalid/overflow/no digits
* Registers:  A, B, X, Y modified. Uses tempWord, digCount.
***********************************************************************
parseDecValue:
        CLR     digCount        ; Reset digit counter
        LDD     #0
        STD     tempWord        ; Initialize result = 0
        LDY     tempPtr         ; Y points to first potential char

pdvLoop:
        LDAA    0,Y             ; Get char into A
        JSR     isDecDigit      ; Check if A is '0'-'9'. C=1 if yes.
        BCC     pdvCheckEnd     ; If not a digit, go check if parsing should end

        ; --- It is a valid decimal digit ---
        LDX     tempWord        ; X = current result (for overflow check)
        LDAA    0,Y             ; Reload digit char into A
        SUBA    #'0'            ; A = digit value (0-9)
        PSHA                    ; *** Push digit value onto stack ***

        ; Check for potential overflow BEFORE multiplying/adding.
        ; Max value is 65535. Check if current_result * 10 + next_digit > 65535
        CPX     #6553           ; Compare current result with 6553
        BHI     pdvOverflow_Pop ; If X > 6553, then X*10 will definitely overflow

        ; If X == 6553, need to check if the incoming digit > 5
        BNE     pdvCanMultiply  ; If X < 6553, multiplication is safe
        ; X is exactly 6553. Check the digit.
        PULA                    ; *** Pop digit value to check it ***
        CMPA    #5              ; Compare digit with 5
        PSHA                    ; *** Push digit value back onto stack *** (still needed for add)
        BHI     pdvOverflow_Pop ; If X == 6553 and digit > 5, then 6553*10 + digit >= 65536 -> overflow

pdvCanMultiply:
        ; Digit value (0-9) is currently on the stack. Multiplication won't overflow.
        LDD     tempWord        ; D = current result
        ; Multiply D by 10 (using shifts and adds)
        CPD     #0              ; Check if current result is 0
        BEQ     pdvAddDigit_Pop ; If result is 0, skip multiply, just add digit (which is on stack)

        ; Multiply non-zero result by 10: D = D*10 = (D*8 + D*2)
        XGDX                    ; Save D (current result) in X temporarily
        LSLD                    ; D = D*2
        LSLD                    ; D = D*4
        LSLD                    ; D = D*8
        ADDD    X               ; D = (D*8) + (original D saved in X) = D*10
        ; No BCS check needed here as overflow was pre-checked
        STD     tempWord        ; Store D*10 result temporarily

pdvAddDigit_Pop:
        ; Digit value (0-9) is still on the stack
        PULA                    ; *** Pop digit value from stack into A ***
        TAB                     ; B = digit value
        CLRA                    ; D = 000 : digit_value
        ADDD    tempWord        ; D = (Result*10) + digit_value
        BCS     pdvOverflow     ; If final add overflows (e.g., 65530 + 6), it's an error. (Stack is clean here)
        STD     tempWord        ; Store final new result

        INC     digCount        ; Count this valid digit
        INY                     ; Advance string pointer Y
        BRA     pdvLoop         ; Go process next character

pdvCheckEnd:
        ; Reached here because current char (in A from pdvLoop) is not a decimal digit
        ; Check if it's a valid terminator (NULL or SPACE)
        CMPA    #NULL
        BEQ     pdvFinalCheck
        CMPA    #SPACE
        BEQ     pdvFinalCheck
        ; If it's neither NULL nor SPACE, it's an invalid character mid-number
        BRA     pdvError        ; Go to error exit

pdvFinalCheck:
        ; Reached end (NULL or SPACE) after parsing potentially valid digits
        TST     digCount        ; Were any digits actually parsed?
        BEQ     pdvError        ; If count is 0 (no digits found), it's an error
        ; Valid decimal number parsed (1 or more digits)
        STY     tempPtr         ; Update caller's pointer to point after the parsed digits
        LDD     tempWord        ; Load the final result into D
        SEC                     ; Set Carry flag for success
        RTS

pdvOverflow_Pop:
        PULA                    ; *** Pop the digit value off stack before error exit ***
pdvOverflow:
        ; Overflow detected during multiplication or final add
pdvError:
        ; Common error exit (invalid char, no digits, overflow)
        CLC                     ; Clear Carry flag for error
        LDD     #0              ; Return 0 in D (optional)
        RTS
        
***********************************************************************
* isHexDigit: Check if A contains a valid hex digit
* Input:      A - ASCII character to check
* Output:     Carry flag - set if valid hex digit, clear if not
* Registers:  A preserved
***********************************************************************
isHexDigit  PSHA                    ; Save A
            
            CMPA        #'0'
            BLO         notHexDigit
            CMPA        #'9'
            BLS         validHexDigit
            CMPA        #'A'
            BLO         notHexDigit
            CMPA        #'F'
            BLS         validHexDigit
            CMPA        #'a'
            BLO         notHexDigit
            CMPA        #'f'
            BLS         validHexDigit
            
notHexDigit CLC                     ; Clear carry - not a hex digit
            PULA                    ; Restore A
            RTS
            
validHexDigit
            SEC                     ; Set carry - valid hex digit
            PULA                    ; Restore A
            RTS

***********************************************************************
* isDecDigit: Check if A contains a valid decimal digit
* Input:      A - ASCII character to check
* Output:     Carry flag - set if valid decimal digit, clear if not
* Registers:  A preserved
***********************************************************************
isDecDigit  PSHA                    ; Save A
            
            CMPA        #'0'
            BLO         notDecDigit
            CMPA        #'9'
            BLS         validDecDigit
            
notDecDigit CLC                     ; Clear carry - not a decimal digit
            PULA                    ; Restore A
            RTS
            
validDecDigit
            SEC                     ; Set carry - valid decimal digit
            PULA                    ; Restore A
            RTS

***********************************************************************
* showMemory: Display memory contents for S command
* Input:      address - Memory address to display
* Output:     Terminal display
* Registers:  All modified
***********************************************************************
showMemory  
            ; Display memory at address in the format:
            ; $3000 => %0001001001101010 $126A 4714
            
            ; Print space at beginning of line for better alignment
            LDAA        #SPACE
            JSR         putchar
            
            ; Print the address with $ prefix
            LDAA        #DOLLAR
            JSR         putchar
            
            ; Debug: print the actual address we're about to use (not the one from the command)
            LDD         address
            JSR         printWordHex
            
            ; Print " => "
            LDX         #spaceArrow
            JSR         printmsg
            
            ; Read memory from the address
            LDX         address      ; Load address into X register
            LDD         0,X          ; Read word from memory at X
            STD         dataValue    ; Store for display
            
            ; Print binary format with % prefix
            LDAA        #'%'
            JSR         putchar
            
            ; Print high byte in binary
            LDAA        dataValue    ; Get high byte
            JSR         printByteBin
            
            ; Print low byte in binary
            LDAA        dataValue+1  ; Get low byte
            JSR         printByteBin
            
            ; Print spaces (exactly 4 spaces)
            LDAA        #SPACE
            JSR         putchar
            JSR         putchar
            JSR         putchar
            JSR         putchar
            
            ; Print hex format with $ prefix
            LDAA        #DOLLAR
            JSR         putchar
            
            ; Print data in hex
            LDD         dataValue    ; Load data value
            JSR         printWordHex
            
            ; Print spaces (exactly 4 spaces)
            LDAA        #SPACE
            JSR         putchar
            JSR         putchar
            JSR         putchar
            JSR         putchar
            
            ; Print decimal value
            LDD         dataValue    ; Load data value
            JSR         printWordDec
            
            ; Print newline
            LDX         #msgLF
            JSR         printmsg
            
            RTS

***********************************************************************
* writeMemory: Write to memory for W command
* Input:      address - Memory address to write to
*             dataValue - Data value to write
* Output:     Terminal display showing written data
* Registers:  All modified
***********************************************************************
writeMemory
            ; Write the data value to memory
            LDX         address      ; Load address into X register
            LDD         dataValue    ; Get data to write
            STD         0,X          ; Store to memory at X
            
            ; Now display the result 
            JSR         showMemory
            
            RTS

***********************************************************************
* printByteBin: Print a byte in binary format (8 bits) - CORRECTED
* Input:      A - byte to print
* Output:     Prints 8 '0' or '1' characters
* Registers:  A, B modified
***********************************************************************
printByteBin:
            PSHA                    ; Save original byte A
            LDAB        #8          ; B = loop counter (8 bits)
            ; A holds the byte whose bits we want to print, MSB first
pBinLoop_Fixed:
            ASLA                    ; Shift MSB of A into Carry. A is modified (shifted left).
            PSHA                    ; Save modified A (because putchar clobbers A)
            LDAA        #'0'        ; Assume bit was 0
            BCC         pBinZero_Fixed ; If Carry Clear, bit was 0
            LDAA        #'1'        ; If Carry Set, bit was 1
pBinZero_Fixed:
            JSR         putchar     ; Print '0' or '1'
            PULA                    ; Restore modified A (shifted value)
            DECB                    ; Decrement bit counter
            BNE         pBinLoop_Fixed; Loop for all 8 bits

            PULA                    ; Restore original A from the start
            RTS
***********************************************************************
* printByteHex: Print a byte in hexadecimal format
* Input:      A - byte to print
* Output:     Terminal display
* Registers:  A, B modified
***********************************************************************
printByteHex
            PSHA                    ; Save original value
            
            ; Print high nibble
            TAB                     ; Copy to B
            LSRB                    ; Shift right four times
            LSRB
            LSRB
            LSRB
            ANDB        #$0F        ; Mask to 4 bits
            ADDB        #'0'        ; Convert to ASCII
            CMPB        #'9'+1
            BLO         pHex1
            ADDB        #7          ; Adjust for A-F
pHex1       TBA                     ; Transfer B to A
            JSR         putchar
            
            ; Print low nibble
            PULA                    ; Restore value
            ANDA        #$0F        ; Mask to low 4 bits
            ADDA        #'0'        ; Convert to ASCII
            CMPA        #'9'+1
            BLO         pHex2
            ADDA        #7          ; Adjust for A-F
pHex2       JSR         putchar
            
            RTS

***********************************************************************
* printWordHex: Print a 16-bit word in hexadecimal format
* Input:      D - word to print (A:B)
* Output:     Terminal display
* Registers:  A, B modified (uses PSHB/PULB internally)
***********************************************************************
printWordHex
        PSHB            ; Save original Low Byte (B) from D register onto stack
        ; A still holds the original High Byte from D register
        JSR printByteHex ; Print High Byte (using A). This call modifies A and B.
        PULB            ; Restore original Low Byte from stack into B.
        TBA             ; Transfer original Low Byte (now in B) into A.
        JSR printByteHex ; Print original Low Byte (now in A). Modifies A, B again.
        RTS             ; Return. Stack is balanced.
***********************************************************************
* printWordDec: Print a 16-bit word in decimal format
* Input:      D - word to print
* Output:     Terminal display
* Registers:  A, B, X, Y modified (PSHX/Y, PULX/Y used)
***********************************************************************
printWordDec
        PSHX                    ; Save X
        PSHY                    ; Save Y
        
        CLR     digCount        ; Use memory variable for count, clear it first

        ; Special case for zero
        CPD     #0
        BNE     pwdNZ_v9
        LDAA    #'0'
        JSR     putchar
        BRA     pwdDone_v9      ; Go directly to cleanup/RTS

pwdNZ_v9
        ; --- Division loop ---
pwdDivLoop_v9
        LDX     #10             ; X = Divisor = 10
        ; D = number to divide
        IDIV                    ; D / X => X = Quotient, D = Remainder
        ; Remainder (0-9) is now in D (specifically B)
        PSHB                    ; Push Remainder (B) onto stack
        INC     digCount        ; Increment counter in memory
        TFR     X,D             ; D = Quotient
        CPD     #0
        BNE     pwdDivLoop_v9   ; Loop if quotient != 0

        ; --- Print loop ---
        ; digCount holds the count of digits pushed.
pwdPrintLoop_v9
        LDAA    digCount        ; Load count into A
        BEQ     pwdDone_v9      ; Branch if count is zero (finished)
        DEC     digCount        ; Decrement count in memory *before* popping/printing
        PULB                    ; Pop digit (Remainder 0-9) into B
        ADDB    #'0'            ; Convert popped digit to ASCII IN B
        TBA                     ; Transfer ASCII char from B to A
        JSR     putchar         ; Print the digit
        BRA     pwdPrintLoop_v9 ; Loop back to check count again

pwdDone_v9
        PULY                    ; Restore original Y
        PULX                    ; Restore original X
        RTS

***********************************************************************
* typewriter: Simple typewriter program
* Input:      None
* Output:     Echo input characters until reset
* Registers:  A modified
***********************************************************************
typewriter  JSR         getchar     ; Get a character
            JSR         putchar     ; Echo the character
            BRA         typewriter  ; Loop forever

***********************************************************************
* Utility Subroutines
***********************************************************************

***********************************************************************
* printmsg: Print a null-terminated string
* Input:      X - pointer to string
* Output:     Terminal display
* Registers:  A modified, X preserved
***********************************************************************
printmsg    PSHX                    ; Save X
pmsgLoop    LDAA        0,X         ; Get character
            BEQ         pmsgDone    ; If null, done
            JSR         putchar     ; Print it
            INX                     ; Next character
            BRA         pmsgLoop    ; Continue
pmsgDone    PULX                    ; Restore X
            RTS

***********************************************************************
* putchar: Send one character to the terminal
* Input:      A - character to send
* Output:     Terminal display
* Registers:  A preserved
***********************************************************************
putchar     PSHA                    ; Save A
pcharLoop   LDAA        SCISR1      ; Get status
            ANDA        #$80        ; Check TDRE bit
            BEQ         pcharLoop   ; Wait until transmitter ready
            PULA                    ; Restore A
            STAA        SCIDRL      ; Send character
            RTS

***********************************************************************
* getchar: Get one character from the terminal
* Input:      None
* Output:     A - received character
* Registers:  A modified
***********************************************************************
getchar     LDAA        SCISR1      ; Get status
            ANDA        #$20        ; Check RDRF bit
            BEQ         getchar     ; Wait until receiver has data
            LDAA        SCIDRL      ; Get character
            RTS

***********************************************************************
* hexCharToVal: Convert hex character to its value
* Input:      A - ASCII hex character ('0'-'9', 'A'-'F', 'a'-'f')
* Output:     A - Value (0-15) or $FF if invalid
* Registers:  A modified
***********************************************************************
hexCharToVal
            ; Check if digit 0-9
            CMPA        #'0'
            BLO         hctvInvalid  ; Below '0'
            CMPA        #'9'
            BHI         hctvNotDigit ; Above '9'
            
            ; It's a digit 0-9
            SUBA        #'0'         ; Convert to value 0-9
            RTS
            
hctvNotDigit
            ; Check if uppercase A-F
            CMPA        #'A'
            BLO         hctvInvalid  ; Below 'A'
            CMPA        #'F'
            BHI         hctvNotUpper ; Above 'F'
            
            ; It's uppercase A-F
            SUBA        #'A'         ; Subtract 'A'
            ADDA        #10          ; Add 10 for value 10-15
            RTS
            
hctvNotUpper
            ; Check if lowercase a-f
            CMPA        #'a'
            BLO         hctvInvalid  ; Below 'a'
            CMPA        #'f'
            BHI         hctvInvalid  ; Above 'f'
            
            ; It's lowercase a-f
            SUBA        #'a'         ; Subtract 'a'
            ADDA        #10          ; Add 10 for value 10-15
            RTS
            
hctvInvalid  
            LDAA        #$FF         ; Invalid character
            RTS

